// Copyright 2025 Remy Beraud
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2025 Remy Beraud
// Licensed under the Apache License, Version 2.0

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { topologicalSort } from "./utils.js";

/**
 * Writes all generated code to a single output file.
 * @param {string} outputFile - Path to the output file.
 * @param {Array} generatedClasses - Array of generated class objects.
 * @param {Array} generatedSimpleTypes - Array of generated simpleType objects.
 * @param {string} baseJsPath - Path to the Base.js template file.
 */
function writeSingleFile(
  outputFile,
  generatedClasses,
  generatedSimpleTypes,
  baseJsPath
) {
  const outputDir = path.dirname(outputFile);
  fs.mkdirSync(outputDir, { recursive: true });

  const baseCode = fs.readFileSync(baseJsPath, "utf-8").replace(/export /g, "");
  const sortedClasses = topologicalSort(generatedClasses);

  const simpleTypesCode = generatedSimpleTypes
    .map((t) => t.code.replace(/export /g, ""))
    .join("\n\n");
  const allClassCode = sortedClasses.map((c) => c.code).join("\n");

  const finalCode = [
    "// Auto-generated by XSD-to-ES6-Class generator",
    baseCode,
    simpleTypesCode,
    allClassCode,
    "export { Base }", // Add exports as needed
  ].join("\n\n");

  fs.writeFileSync(outputFile, finalCode);
}

/**
 * Writes each generated class to its own file in an output directory.
 * @param {string} outputDir - Path to the output directory.
 * @param {Array} generatedClasses - Array of generated class objects.
 * @param {Array} generatedSimpleTypes - Array of generated simpleType objects.
 * @param {string} baseJsPath - Path to the Base.js template file.
 */
function writeMultipleFiles(
  outputDir,
  generatedClasses,
  generatedSimpleTypes,
  baseJsPath
) {
  fs.mkdirSync(outputDir, { recursive: true });
  fs.copyFileSync(baseJsPath, path.join(outputDir, "Base.js"));

  const allTypeNames = new Set([
    ...generatedClasses.map((c) => c.className),
    ...generatedSimpleTypes.map((st) => st.typeName),
  ]);

  // Write simple types to their own file
  if (generatedSimpleTypes.length > 0) {
    const simpleTypeCode = generatedSimpleTypes
      .map((st) => st.code)
      .join("\n\n");

    // Add the import statement at the beginning
    const finalSimpleTypeCode = `import { Base } from './Base.js';\n\n${simpleTypeCode}`;

    fs.writeFileSync(
      path.join(outputDir, "simpleTypes.js"),
      finalSimpleTypeCode
    );
  }
  generatedClasses.forEach(({ className, code, dependencies }) => {
    const simpleTypeDeps = new Set();
    const classDeps = new Set();

    dependencies.forEach((dep) => {
      if (allTypeNames.has(dep)) {
        // Check if it's a known type
        generatedSimpleTypes.some((st) => st.typeName === dep)
          ? simpleTypeDeps.add(dep)
          : classDeps.add(dep);
      }
    });

    const classImportStatements = Array.from(classDeps)
      .map((dep) => `import { ${dep} } from './${dep}.js';`)
      .join("\n");

    const simpleTypeImport =
      simpleTypeDeps.size > 0
        ? `import { ${Array.from(simpleTypeDeps).join(
            ", "
          )} } from './simpleTypes.js';`
        : "";

    const finalCode = [
      `import { Base } from './Base.js';`,
      simpleTypeImport,
      classImportStatements,
      code.replace(`class ${className}`, `export class ${className}`),
    ]
      .filter(Boolean)
      .join("\n\n");

    fs.writeFileSync(path.join(outputDir, `${className}.js`), finalCode);
  });

  // Create an index.js for easy imports
  const classExports = generatedClasses
    .map((c) => `export * from './${c.className}.js';`)
    .join("\n");
  const simpleTypeExport =
    generatedSimpleTypes.length > 0 ? `export * from './simpleTypes.js';` : "";
  const indexContent = [classExports, simpleTypeExport]
    .filter(Boolean)
    .join("\n");
  fs.writeFileSync(path.join(outputDir, "index.js"), indexContent);
}

/**
 * Writes the Base.js file to the output directory with the correct configuration.
 * @param {string} outputDir - The output directory.
 * @param {string} baseJsPath - The path to the Base.js template file.
 * @param {object} config - The configuration object.
 */
function writeBaseFile(outputDir, baseJsPath, config) {
  let baseJsContent = fs.readFileSync(baseJsPath, "utf-8");

  // Replace the placeholder with the actual boolean value from the config.
  // If config['only-string'] is true, __ONLY_STRING__ becomes 'true',
  // and parseAttributeValue becomes '!true' (i.e., false).
  baseJsContent = baseJsContent.replace(
    /__ONLY_STRING__/g,
    config["only-string"]
  );

  fs.writeFileSync(path.join(outputDir, "Base.js"), baseJsContent);
}

/**
 * Main function to orchestrate file writing based on config.
 * @param {{generatedClasses: any[], generatedSimpleTypes: any[], config: object}} params
 */
export function writeOutput({
  generatedClasses,
  generatedSimpleTypes,
  config,
}) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  // Use template/base.js as the source for Base.js
  const baseJsPath = config.base
    ? path.resolve(config.base)
    : path.resolve(__dirname, "../template/base.js");

  if (config.multipleFiles) {
    writeMultipleFiles(
      config.output,
      generatedClasses,
      generatedSimpleTypes,
      baseJsPath
    );
  } else {
    writeSingleFile(
      config.output,
      generatedClasses,
      generatedSimpleTypes,
      baseJsPath
    );
  }

  // Write the Base.js file with the correct configuration
  writeBaseFile(config.output, baseJsPath, config);
}
